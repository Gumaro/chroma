/***************************************************************************
 * make_ops.cc
 * Driver routine to combine elemental operators generated by 
 * STOCH_GROUP_BARYON into group theoretical baryon operators 
 * *************************************************************************/



#include "chroma.h"
#include "meas/inline/make_xml_file.h"

#include "stdio.h"
#include "string.h"

using namespace QDP;
using namespace Chroma;


struct Param_t
{

	multi1d<int> layout; //Lattice dimensions 
	int decay_dir; //time direction

};

//Structure containing all the input elemental operator info
struct InputFiles_t
{
	//! 3-quark elemental operator structure
	struct ElementalOpFiles_t
	{
		struct Config_t
		{
			struct TimeSlices_t 
			{
				struct Dilutions_t
				{
						std::string src_file;  /*!< File containing the source operator */
						std::string snk_file;  /*!< File containing the sink operator */
				};
				
				multi1d<Dilutions_t> dilutions; /*!< Different dilution elements(per timeslice) may be in different files	*/
				
			};
			
			multi1d<TimeSlices_t> time_slices; /*!< Different dilution timeslices (most likely) will be in different files */

		};

		multi1d<Config_t> cfgs; /*!< List of source and sink op files for each config */

	};	

	multi1d<ElementalOpFiles_t> elem_op_files; /*!< Files containing available three quark ops */
	multi1d<std::string> coeff_files; //Files of all the group-theoretical ops to make 

};

//Structure containing all the output info
struct OutputInfo_t
{

	struct OutputPaths_t
	{
		std::string src_path; //Output path for source operator on this config
		std::string snk_path; //Output path for sink operator on this config
	};

	multi1d< OutputPaths_t > cfg_paths; 	//Group theoretical operator output paths for each config 

};

//! Mega-structure of all input
struct MakeOpsInput_t
{
	Param_t            param;
	OutputInfo_t 			 output_info;	
	InputFiles_t       input_files;

};

// Reader for input parameters
void read(XMLReader& xml, const string& path, Param_t& param)
{
	XMLReader paramtop(xml, path);

	int version;
	read(paramtop, "version", version);

	switch (version) 
	{
		case 1:

			read(paramtop, "Layout", param.layout );
			read(paramtop, "Decay_dir", param.decay_dir);
			break;

		default :
			/**************************************************************************/

			cerr << "Input parameter version " << version << " unsupported." << endl;
			exit(1);
	}
}

//! Reader for operator output paths  
void read(XMLReader& xml, const string& path, OutputInfo_t::OutputPaths_t& input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "SourceOpOutputPath", input.src_path);
	read(inputtop, "SinkOpOutputPath", input.snk_path);
}

//! Reader for output info  
void read(XMLReader& xml, const string& path, OutputInfo_t& input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "CfgOutputPaths", input.cfg_paths);
}

//! Reader for a single dilution (per timeslice) of elemental op files  
void read(XMLReader& xml, const string& path, 
		InputFiles_t::ElementalOpFiles_t::Config_t::TimeSlices_t::Dilutions_t & input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "CreationOperatorFile", input.src_file);
	read(inputtop, "AnnihilationOperatorFile", input.snk_file);
}

//! Reader for a single dilution timeslice of elemental op files 
void read(XMLReader& xml, const string& path, InputFiles_t::ElementalOpFiles_t::Config_t::TimeSlices_t & input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "DilutionsPerTimeSlice", input.dilutions);
}

//! Reader for a single config of elemental operator files 
void read(XMLReader& xml, const string& path, InputFiles_t::ElementalOpFiles_t::Config_t& input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "DilutionTimeSlices", input.time_slices);
}

//! Reader for elemental operator files 
void read(XMLReader& xml, const string& path, InputFiles_t::ElementalOpFiles_t& input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "Configs", input.cfgs);
}


//! Reader for input files 
void read(XMLReader& xml, const string& path, InputFiles_t& input)
{
	XMLReader inputtop(xml, path);

	read(inputtop, "CoeffFiles", input.coeff_files);
	read(inputtop, "ElementalOpFiles", input.elem_op_files);

}

// Reader for input parameters
void read(XMLReader& xml, const string& path, MakeOpsInput_t& input)
{
	XMLReader inputtop(xml, path);

	// Read all the input groups
	try
	{
		// Read program parameters
		read(inputtop, "Param", input.param);

		// Read in the input files 
		read(inputtop, "InputFiles", input.input_files);

		// Read in the ouput info 
		read(inputtop, "OutputInfo", input.output_info);

	}
	catch (const string& e) 
	{
		cerr << "Error reading make_ops data: " << e << endl;
		exit(1);
	}
}

//! Baryon operator
struct BaryonOperator_t
{
	//! Baryon operator time slices corresponding to location of operator source
	struct TimeSlices_t
	{
		//! Quark orderings within a baryon operator
		struct Orderings_t
		{
			//! Baryon operator dilutions
			struct Dilutions_t
			{
				//! Momentum projected correlator
				struct Mom_t
				{
					multi1d<int>       mom;         /*!< D-1 momentum of this operator */
					multi1d<DComplex>  op;          /*!< Momentum projected operator */
				};

				multi1d<Mom_t> mom_projs;         /*!< Holds momentum projections of the operator */
			};

			multi1d<int> perm;                  /*!< This particular permutation of quark orderings */

			multi3d<Dilutions_t> dilutions;     /*!< Hybrid list indices */
		};

		multi1d<Orderings_t> orderings;  			/*!< Array is over quark orderings */

	};

	multi1d< multi1d<int> > perms;   /*!< Permutations of quark enumeration */

	GroupXML_t    smearing;          /*!< String holding quark smearing xml */

	Seed          seed_l;            /*!< Id of left quark */
	Seed          seed_m;            /*!< Id of middle quark */
	Seed          seed_r;            /*!< Id of right quark */

	std::string   id;                /*!< Tag/ID used in analysis codes */

	int           mom2_max;          /*!< |\vec{p}|^2 */
	int           decay_dir;         /*!< Direction of decay */

	multi1d<TimeSlices_t> time_slices; /*!< Time slices of the lattice that are used */
};

struct GroupBaryonOperator_t
{
	struct Term_t
	{ 
		struct ThreeQuarkOp_t
		{
			struct QuarkInfo_t
			{
				int  displacement;    /*!< Orig plus/minus 1-based directional displacements */
				int  spin;            /*!< 1-based spin index */
			};

			multi1d<QuarkInfo_t> quarks;
		};

		ThreeQuarkOp_t op;
		DComplex coeff;
	};

	multi1d<Term_t> term;
	
	std::string name; 
	
};


//! BaryonOperator header reader
void read(XMLReader& xml, const string& path, BaryonOperator_t& param)
{
  XMLReader paramtop(xml, path);

  try
  {
    	int version;
  	  read(paramtop, "version", version);
      read(paramtop, "id", param.id);
      read(paramtop, "mom2_max", param.mom2_max);
      read(paramtop, "decay_dir", param.decay_dir);
      read(paramtop, "seed_l", param.seed_l);
      read(paramtop, "seed_m", param.seed_m);
      read(paramtop, "seed_r", param.seed_r);
      read(paramtop, "perms", param.perms);
  
			//read the smearing??!!
	}
  catch (const std::string& e) 
  {
    cerr << "BaryonOperator: Error reading: " << e << endl;
    exit(1);
  }
}

//! BaryonOperator header writer 
void write(XMLWriter& xml, const string& path, BaryonOperator_t& param)
{
  push(xml, path);

  try
  {
    
      write(xml, "id", param.id);
      write(xml, "mom2_max", param.mom2_max);
      write(xml, "decay_dir", param.decay_dir);
      write(xml, "seed_l", param.seed_l);
      write(xml, "seed_m", param.seed_m);
      write(xml, "seed_r", param.seed_r);
      write(xml, "perms", param.perms);
  
			//write the smearing??
	}
  catch (const std::string& e) 
  {
    cerr << "BaryonOperator: Error writing: " << e << endl;
    exit(1);
  }

	pop(xml);

}

//GroupBaryonOperator Writer
void write(XMLWriter &xml, const std::string &path, 
		const GroupBaryonOperator_t::Term_t::ThreeQuarkOperator_t::QuarkInfo_t &param)
{
	push(xml, path);

	write(xml, "Spin" , param.spin);
	write(xml, "Displacement" , param.displacement);

	pop(xml);

}

//GroupBaryonOperator Writer
void write(XMLWriter &xml, const std::string &path, const GroupBaryonOperator_t::Term_t::ThreeQuarkOperator_t &param)
{
	push(xml, path);

	write(xml, "Quarks" , param.quarks);

	pop(xml);

}

//GroupBaryonOperator Writer
void write(XMLWriter &xml, const std::string &path, const GroupBaryonOperator_t::Term_t &param)
{
	push(xml, path);

	write(xml, "ElementalOperator" , param.op);
	write(xml, "Coefficient" , param.coeff);

	pop(xml);

}	

//GroupBaryonOperator Writer
void write(XMLWriter &xml, const std::string &path, const GroupBaryonOperator_t &param)
{
	push(xml, path);

	write(xml, "Name" , param.name);
	write(xml, "Terms" , param.term);

	pop(xml);

}	
//! BaryonOperator binary reader
    void write(BinaryReader& bin, const BaryonOperator_t::TimeSlices_t::Orderings_t::Dilutions_t::Mom_t& param)
    {
      read(bin, param.mom);
      read(bin, param.op);
    }

    //! BaryonOperator binary reader 
    void write(BinaryReader& bin, const BaryonOperator_t::TimeSlices_t::Orderings_t::Dilutions_t& param)
    {
      read(bin, param.mom_projs);
    }

    //! BaryonOperator binary reader 
    void read(BinaryReader& bin, const BaryonOperator_t::TimeSlices_t::Orderings_t& param)
    {
      read(bin, param.dilutions);
    	read(bin, param.perm);
		}

    //! BaryonOperator binary reader 
    void write(BinaryReader& bin, const BaryonOperator_t::TimeSlices_t& param)
    {
      read(bin, param.orderings);
    }

    //! BaryonOperator binary reader 
    void read(BinaryReader& bin, const BaryonOperator_t& param)
    {
      read(bin, param.seed_l);
      read(bin, param.seed_m);
      read(bin, param.seed_r);
      read(bin, param.mom2_max);
      read(bin, param.decay_dir);
      read(bin, param.perms);
      read(bin, param.time_slices);
    }


//! BaryonOperator binary writer
    void write(BinaryWriter& bin, const BaryonOperator_t::TimeSlices_t::Orderings_t::Dilutions_t::Mom_t& param)
    {
      write(bin, param.mom);
      write(bin, param.op);
    }

    //! BaryonOperator binary writer
    void write(BinaryWriter& bin, const BaryonOperator_t::TimeSlices_t::Orderings_t::Dilutions_t& param)
    {
      write(bin, param.mom_projs);
    }

    //! BaryonOperator binary writer
    void write(BinaryWriter& bin, const BaryonOperator_t::TimeSlices_t::Orderings_t& param)
    {
      write(bin, param.dilutions);
    	write(bin, param.perm);
		}

    //! BaryonOperator binary writer
    void write(BinaryWriter& bin, const BaryonOperator_t::TimeSlices_t& param)
    {
      write(bin, param.orderings);
    }

    //! BaryonOperator binary writer
    void write(BinaryWriter& bin, const BaryonOperator_t& param)
    {
      write(bin, param.seed_l);
      write(bin, param.seed_m);
      write(bin, param.seed_r);
      write(bin, param.mom2_max);
      write(bin, param.decay_dir);
      write(bin, param.perms);
      write(bin, param.time_slices);
    }

//This routine goes through (possibly several) coeff files and fills 
//the operator array
void readCoeffFiles(multi1d<GroupBaryonOperator_t> &ops, const multi1d<std::string> coeff_files) 
{

	int nops = 0;

	//First determine how many ops total 
	for (int i = 0 ; i < coeff_files.size() ; ++i)
	{

		TextFileReader reader(coeff_files[i]);

		int op;

		reader >> op;

		reader.close();

		nops += op; 
		
	//	QDPIO::cout<< "Nops = "<<nops<<endl;

	}

	ops.resize(nops);
	
	//Now read the coeffs

	for (int i = 0 ; i < coeff_files.size() ; ++i)
	{

		int op;

		TextFileReader reader(coeff_files[i]);
		reader >> op;
		
		for (int l = 0 ; l < op ; ++l)
		{
			int nelem;
			std::string name; 
			reader >> nelem >> name;

			ops[ i + l ].name = name;

			ops[ i + l ].term.resize( nelem );

			for (int m = 0 ; m < nelem ; ++m)
			{
				int a,b,c,i,j,k;
				Real re,im;
				char lparen,comma,rparen;

				reader >> a >> b >> c >> i >> j >> k >> lparen >> re >> comma >> im >> rparen;

				ops[ i + l].term[m].coeff = cmplx( re, im );

				ops[ i + l].quarks[0].spin = a;
				ops[ i + l].quarks[1].spin = b;
				ops[ i + l].quarks[2].spin = c;

				ops[ i + l].quarks[0].displacement = i;
				ops[ i + l].quarks[0].displacement = j;
				ops[ i + l].quarks[0].displacement = k;

			} //m
			
	} //l 

	 		
	reader.close();

	} //i

}//void


//Fill the operator info from first elem. op so it isn't done for every 
//elem op
void initOp (BaryonOperator_t &oper , const BaryonOperator_t &elem_oper ) 
{
	oper.mom2_max= elem_oper.mom2_max;
	oper.decay_dir = elem_oper.decay_dir;
	oper.seed_l = elem_oper.seed_l;
	oper.seed_m = elem_oper.seed_m;
	oper.seed_r = elem_oper.seed_r;
	oper.perms = elem_oper.perms;	

	int Nord = elem_oper.perms.size();
	int Nt = elem_oper.orderings[0].time_slices.size();

	oper.time_slices.resize(Nt);

	for (int t0 = 0 ; t0 < Nt ; ++t0)
	{
		oper.time_slices[t0].orderings.resize(Nord);

		oper.time_slices[t0].t0 = elem_oper.time_slices[t0].t0;

		for (int p = 0 ; p < Nord ; ++p)
		{
			oper.time_slices[t0].orderings[p].perm = elem_oper.time_slices[t0].orderings[p].perm;

			//Dilution sizes for each quark
			int Ni = elem_oper.time_slices[t0].orderings[p].dilutions.size1();
			int Nj = elem_oper.time_slices[t0].orderings[p].dilutions.size2();
			int Nk = elem_oper.time_slices[t0].orderings[p].dilutions.size3();

			oper.time_slices[t0].orderings[p].dilutions.resize(Ni, Nj, Nk);

			for(int i = 0 ; i < Ni ; ++i)   	
				for(int j = 0 ; j < Nj ; ++j)   	
					for(int k = 0 ; k < Nk ; ++k)   	
					{
						int Nmom =  elem_oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs.size();

						oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs.resize(Nmom);

						for (int m = 0 ; m < Nmom ; ++m)
						{
							oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs[m].mom = 
								elem_oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs[m].mom;

							//zero operator
							int Lop = elem_oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs[m].op.size();

							oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs[m].op.resize(Lop);

							for (int t = 0 ; t < Lop ; ++t)
							{
								oper.orderings[p].time_slices[t_0].dilutions(i,j,k).mom_projs[m].op[t] = zero;
							}

						} //m
					}//ijk
		}//t_0
	}//p

} //void



//Add the elemental op to the final operator
void addTo(BaryonOperator_t &oper, const BaryonOperator_t &elem_oper, 
		const DComplex& coeff)
{

	int Nord = elem_oper.perms.size();
	int Nt = elem_oper.time_slices.size();


	for (int t0 = 0 ; t0 < Nt ; ++t0)
	{

		for (int p = 0 ; p < Nord ; ++p)
		{
			
			for(int i = 0 ; i < elem_oper.time_slices[t0].orderings[p].dilutions.size1() ; ++i)   	
				for(int i = 0 ; i < elem_oper.time_slices[t0].orderings[p].dilutions.size1() ; ++i)   	
					for(int i = 0 ; i < elem_oper.time_slices[t0].orderings[p].dilutions.size1() ; ++i)   	
					{
						
						for (int m = 0 ; m < elem_oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs.size() ; ++m)
						{
							oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs[m].op += 
								elem_oper.time_slices[t0].orderings[p].dilutions(i,j,k).mom_projs[m].op * coeff;
						} //m
					}//ijk
		}//p
	}//t_0

} //void

//Test if all elemental ops have the same configs, dilution schemes, seeds, decay_dirs 
//Will also return true for inconsistentcies within opB
bool opsError(const multi1d<InputFiles_t::ElementalOpFiles_t> ops) 
{
	bool error = false;

	//Tests
	{
		Nbins = ops[0].cgs.size();

		//first check that all the ops have the same number of configs 
  	for (int i = 0 ; i < ops.size() ; ++i )  	
		{

			notEqual |= toBool(ops[i].cfgs.size() = opB.cfgs.size());
		
		if (notEqual)
		{
			QDPIO::cerr<< "Invalid number of configs"<<endl; 
			break;
		}

		//Now check that the configs are the same for the two ops as well as for 
		for (int n = 0 ; n = 



int main(int argc, char **argv)
{

	// Put the machine into a known state
  Chroma::initialize(&argc, &argv);
  //  linkageHack();

  // Put this in to enable profiling etc.
  START_CODE();

	//Read Input params from xml
	MakeOpsInput_t input;

	XMLReader xml_in;
	
	StopWatch swatch, snoop;
	
	swatch.reset();
	swatch.start();

	try
  {
    xml_in.open(Chroma::getXMLInputFileName());
    read(xml_in, "/MakeOps", input);
  }
  catch(const std::string& e) 
  {
    QDPIO::cerr << "MAKEOPS: Caught Exception reading XML: " << e << endl;
    QDP_abort(1);
  }
  catch(std::exception& e) 
  {
    QDPIO::cerr << "MAKEOPS: Caught standard library exception: " << e.what() << endl;
    QDP_abort(1);
  }
  catch(...)
  {
    QDPIO::cerr << "MAKEOPS: caught generic exception reading XML" << endl;
    QDP_abort(1);
  }

  XMLFileWriter& xml_out = Chroma::getXMLOutputInstance();
  push(xml_out, "MakeOps");

  // Write out the input
  write(xml_out, "Input", xml_in);

  Layout::setLattSize(input.param.layout);
  Layout::create();   // Setup the layout
	
	multi1d<GroupBaryonOperator_t> final_ops;

	QDPIO::cout<< "Reading Coeff Files" << endl;

	//Read coeff files 
	readCoeffFiles(final_ops, input.files.coeff_files);
	

	int time_dir = input.param.decay_dir;
	int Nt = input.param.layout[time_dir]; 
	int Nops = final_ops.size();
	int Nelem = input.input_files.elem_op_files.size();
	int Nbins = input.input_files.elem_op_files[0].cfgs.size();

	multi1d<int> participating_timeslices = getParticipatingTimes(
			input.input_files.elem_op_files[0].cfg[0]);

	//-------------------------------------------------------------
	//Sanity Checks
		
	//Does the number of configs to ouput agree with input?
	if ( input.output_info.cfg_paths.size() != Nbins )
	{
		QDPIO::cerr << "Number of ouput config paths not equal to that of input." << endl;
		QDP_abort(1);
	}

	//Does each input op contain the same configs, dilution scheme, quarks, time dir?
	for (int l = 1 ; l < Nelem ; ++l)
	{
		//I'm afraid of overloading the != operator here 
		if ( input.input_files.elem_op_files[l] != input.input_files.elem_op_files[0])
		{
			QDPIO::cerr << "Inconsistent configs, dilution scheme, or quark seeds: Elemental Op "<< l <<endl;
			QDP_abort(1);
		}
	}

	//-------------------------------------------------------------

	//Write oplist to output xml
	write(xml_out, "GroupBaryonOperators", final_ops);

	QDPIO::cout << " MAKE_OPS: construct baryon operators" << endl;

	//Elemental Operator maps 
	ElemetentalOpMaps el_op_maps(input.input_files.elem_op_files);
		
	//loop over configurations
	for (int i = 0 ; i < Nbins ; ++i)
	{
		QDPIO::cout << "Forming Ops: Bin "<< i << endl; 

		for (int l = 0 ; l < Nops ; ++l)
		{
		 	
			//Make Source
			{	
				BaryonOperator_t source;
				source.id = final_ops[l].name; 
			
				snoop.reset();
				snoop.start();
				
				QDPIO::cout<< "Making Source Baryon Op: " << source.id << endl;

				int Nterms = final_ops[l].term.size();

				bool init = false;

				for (int m = 0 ; m < Nterms ; ++m)
				{
				
					ElementalOpKey_t elOpKey;

					elOpKey.cfg = i;
					elOpKey.op = final_ops[l].term[m].op;
				
					BaryonOperator_t elem_source = el_op_maps.getSourceOp(elOpKey);

					if (!init)
					{

						QDPIO::cout<<"init. group baryon op source"<<endl;				
						//Set all the headers, perms, mom_projs, t_0's only once 
						initOp(source , elem_source);
			
						QDPIO::cout<<"Finished init ops"<<endl;
						init = true;
					}

					QDPIO::cout<<"Adding elemental to group baryon op"<<endl;
				
					//add the elem op to the final op
					addTo(source, elem_source, final_ops[l].term[m].coeff);
				
				} //m

				snoop.stop();
				QDPIO::cout<<"Source op constructed: "<< snoop.getTimeInSeconds() << " secs " 
					<< endl;


				snoop.reset();
				snoop.start();
				
				//Write Source Op
				
				QDPIO::cout<<" Writing Source Op"<<endl;

				XMLBufferWriter file_xml; 

				//Put some stuff in the file xml; 
				write(file_xml, "SourceGroupBaryonOperator", final_ops[l]);

				BinaryBufferWriter source_bin; 

				std::string filename = input.output_info.cfg_paths[i] + op[l].name + "_src.lime";

				QDPIO::cout<<"Source Filename = "<<srcfilename<<endl;

				QDPFileWriter srcout(file_xml, filename, QDPIO_SINGLEFILE, QDPIO_SERIAL, QDPIO_OPEN);

				XMLBufferWriter source_xml;
				
				//put some stuff in the source xml
				write(source_xml, "CreationOperator" , source);

				write(source_bin, source);
				write(srcout, source_xml, source_bin);


				snoop.stop();

				QDPIO::cout<<"Source Op Written : time = "<< snoop.getTimeInSeconds() << "sec"<<endl;

			}//Source
				
			
			//Make Sink 
			{	
				BaryonOperator_t sink;
				sink.id = final_ops[l].name; 
			
				QDPIO::cout<< "Making Sink Baryon Op: " << sink.id << endl;

				int Nterms = final_ops[l].term.size();

				bool init = false;

				for (int m = 0 ; m < Nterms ; ++m)
				{
				
					ElementalOpKey_t elOpKey;

					elOpKey.cfg = i;
					elOpKey.op = final_ops[l].term[m].op;
				
					BaryonOperator_t elem_sink = el_op_maps.getSinkOp(elOpKey);

					if (!init)
					{

						QDPIO::cout<<"init. group baryon op sink"<<endl;				
						//Set all the headers, perms, mom_projs, t_0's only once 
						initOp(sink , elem_sink);
			
						QDPIO::cout<<"Finished init ops"<<endl;
						init = true;
					}

					QDPIO::cout<<"Adding elemental to group baryon op"<<endl;
				
					//add the elem op to the final op
					addTo(sink, elem_sink, final_ops[l].term[m].coeff);
				
				} //m
			
				//Write Sink Op
				QDPIO::cout<<" Writing Sink Op"<<endl;

				XMLBufferWriter file_xml; 

				//Put some stuff in the file xml; 
				write(file_xml, "SinkGroupBaryonOperator", final_ops[l]);

				BinaryBufferWriter sink_bin; 

				std::string filename = input.output_info.cfg_paths[i] + op[l].name + "_snk.lime";

				QDPIO::cout<<"Sink Filename = "<<filename<<endl;

				QDPFileWriter snkout(file_xml, filename, QDPIO_SINGLEFILE, QDPIO_SERIAL, QDPIO_OPEN);

				XMLBufferWriter sink_xml;
				
				//put some stuff in the sink xml
				write(sink_xml, "AnnihilationOperator" , sink);

				write(sink_bin, sink);
				write(snkout, sink_xml, sink_bin);

				snoop.stop();
				QDPIO::cout<<"Sink Op Written : time = "<< snoop.getTimeInSeconds() << "sec"<<endl;

			}//Sink
		
		} //l

	}//i		

	pop(xml_out); //MakeOps 


	swatch.stop();

	QDIO::cout<<"MakeOps ran sucessfully: total time = "<< swatch.getTimeInSeconds() << "sec" << endl;


	// Clean up QDP++
  QDP_finalize();
  exit(0);  // Normal exit
}


